.. _user-plugins:

Plugins
#######

Plugins are used to add specific data processing or to modify the regular pipeline in certain way. However, the functionality they provide is not considered essential.

If the simulation is started without postprocess part (see :ref:`user-all`), most of the plugins are disabled.

.. comment libudevicex.Plugins
   :members:
   :show-inheritance:
   :undoc-members:
          

.. py:module:: libudevicex.Plugins


.. py:class:: AddForce
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will add constant force :math:`\mathbf{F}_{extra}` to each particle of a specific PV every time-step.
Is is advised to only use it with rigid objects, since Velocity-Verlet integrator with constant pressure can do the same without any performance penalty.


.. py:class:: AddTorque
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will add constant torque :math:`\mathbf{T}_{extra}` to each *object* of a specific OV every time-step.


.. py:class:: Average3D
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will project certain quantities of the particles on the grid (by simple binning),
perform time-averaging of the grid and dump it in XDMF (LINK) format with HDF5 (LINK) backend.
The quantities of interest are represented as *channels* associated with particles vectors.
Some interactions, integrators, etc. and more notable plug-ins can add to the Particle Vectors per-particles arrays to hold different values.
These arrays are called *channels*.
Any such channel may be used in this plug-in, however, user must explicitely specify the type of values that the channel holds.
Particle number density is used to correctly average the values, so it will be sampled and written in any case.

.. note::
    This plugin is inactive if postprocess is disabled


.. py:class:: AverageRelative3D
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin acts just like the regular flow dumper, with one difference.
It will assume a coordinate system attached to the center of mass of a specific object.
In other words, velocities and coordinates sampled correspond to the object reference frame.

.. note::
    Note that this plugin needs to allocate memory for the grid in the full domain, not only in the corresponding MPI subdomain.
    Therefore large domains will lead to running out of memory

.. note::
    This plugin is inactive if postprocess is disabled


.. py:class:: ImposeProfile
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

TODO


.. py:class:: ImposeVelocity
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will add velocity to all the particles of the target PV in the specified area (rectangle) such that the average velocity equals to desired.


.. py:class:: MeshDumper
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.PostprocessPlugin`


.. py:class:: MeshPlugin
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will write the meshes of all the object of the specified Object Vector in a PLY format (LINK).

.. note::
    This plugin is inactive if postprocess is disabled


.. py:class:: ObjPositions
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will write the coordinates of the centers of mass of the objects of the specified Object Vector.
If the objects are rigid bodies, also will be written: COM velocity, rotation, angular velocity, force, torque.

The file format is the following:

<object id> <simulation time> <COM>x3 [<quaternion>x4 <velocity>x3 <angular velocity>x3 <force>x3 <torque>x3]

.. note::
    Note that all the written values are *instantaneous*

.. note::
    This plugin is inactive if postprocess is disabled


.. py:class:: ObjPositionsDumper
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.PostprocessPlugin`


.. py:class:: PinObject
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will fix center of mass positions (by axis) of all the objects of the specified Object Vector.
If the objects are rigid bodies, rotatation may be restricted with this plugin as well.
The *average* force or torque required to fix the positions or rotation are reported.

.. note::
    This plugin is inactive if postprocess is disabled


.. py:class:: PostprocessPlugin
   :module: libudevicex.Plugins

   Bases: :class:`pybind11_builtins.pybind11_object`

Base postprocess plugin class


.. py:class:: PostprocessStats
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.PostprocessPlugin`


.. py:class:: ReportPinObject
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.PostprocessPlugin`


.. py:class:: SimulationPlugin
   :module: libudevicex.Plugins

   Bases: :class:`pybind11_builtins.pybind11_object`

Base simulation plugin class


.. py:class:: SimulationStats
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will report aggregate quantities of all the particles in the simulation:
total number of particles in the simulation, average temperature and momentum, maximum velocity magnutide of a particle
and also the mean real time per step in milliseconds.

.. note::
    This plugin is inactive if postprocess is disabled


.. py:class:: Temperaturize
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

TODO


.. py:class:: UniformCartesianDumper
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.PostprocessPlugin`


.. py:class:: VelocityControl
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin applies a uniform force to all the particles of the target PV in the specified area (rectangle).
The force is apdated by a PID controller such that the velocity average of the particles matches a target average velocity.


.. py:class:: WallRepulsion
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will add force on all the particles that are nearby a specified wall. The motivation of this plugin is as follows.
The particles of regular PVs are prevented from penetrating into the walls by Wall Bouncers.
However, using Wall Bouncers with Object Vectors may be undesirable (e.g. in case of a very viscous membrane) or impossible (in case of rigid objects).
In these cases one can use either strong repulsive potential between the object and the wall particle or alternatively this plugin.
The advantage of the SDF-based repulsion is that small penetrations won't break the simulation.

The force expression looks as follows:

.. math::

    \mathbf{F} = \mathbf{\nabla}_{sdf} \cdot \begin{cases}
        0, & sdf < -h\\
        \min(F_{max}, C (sdf + h)), & sdf \geqslant -h\\
    \end{cases}


.. py:class:: XYZDumper
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.PostprocessPlugin`


.. py:class:: XYZPlugin
   :module: libudevicex.Plugins

   Bases: :class:`libudevicex.Plugins.SimulationPlugin`

This plugin will dump positions of all the particles of the specified Particle Vector in the XYZ format.

.. note::
    This plugin is inactive if postprocess is disabled


.. py:function:: createAddForce(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, force: Tuple[float, float, float]) -> Tuple[libudevicex.Plugins.AddForce, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :any:`ParticleVector` that we'll work with
:param force: extra force


.. py:function:: createAddTorque(compute_task: bool, name: str, ov: libudevicex.ParticleVectors.ParticleVector, torque: Tuple[float, float, float]) -> Tuple[libudevicex.Plugins.AddTorque, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param ov: :any:`ObjectVector` that we'll work with
:param torque: extra torque (per object)


.. py:function:: createDumpAverage(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, sample_every: int, dump_every: int, bin_size: Tuple[float, float, float] = (1.0, 1.0, 1.0), channels: List[Tuple[str, str]], path: str = 'xdmf/') -> Tuple[libudevicex.Plugins.Average3D, libudevicex.Plugins.UniformCartesianDumper]
   :module: libudevicex.Plugins


:param name: name of the plugin
:param pv: :any:`ParticleVector` that we'll work with
:param sample_every: sample quantities every this many time-steps
:param dump_every: write files every this many time-steps
:param bin_size: bin size for sampling. The resulting quantities will be *cell-centered*
:param path: Path and filename prefix for the dumps. For every dump two files will be created: <path>_NNNNN.xmf and <path>_NNNNN.h5
:param channels: list of pairs name - type.
                 Name is the channel (per particle) name. Always available channels are:

                 * 'velocity' with type "float8"
                 * 'force' with type "float4"

                 Type is to provide the type of quantity to extract from the channel.
                 Type can also define a simple transformation from the channel internal structure
                 to the datatype supported in HDF5 (i.e. scalar, vector, tensor)
                 Available types are:

                 * 'scalar': 1 float per particle
                 * 'vector': 3 floats per particle
                 * 'vector_from_float4': 4 floats per particle. 3 first floats will form the resulting vector
                 * 'vector_from_float8' 8 floats per particle. 5th, 6th, 7th floats will form the resulting vector.
                     This type is primarity made to be used with velocity since it is stored together with
                     the coordinates as 8 consecutive float numbers: (x,y,z) coordinate, followed by 1 padding value
                     and then (x,y,z) velocity, followed by 1 more padding value
                 * 'tensor6': 6 floats per particle, symmetric tensor in order xx, xy, xz, yy, yz, zz


.. py:function:: createDumpAverageRelative(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, relative_to_ov: libudevicex.ParticleVectors.ObjectVector, relative_to_id: int, sample_every: int, dump_every: int, bin_size: Tuple[float, float, float] = (1.0, 1.0, 1.0), channels: List[Tuple[str, str]], path: str = 'xdmf/') -> Tuple[libudevicex.Plugins.AverageRelative3D, libudevicex.Plugins.UniformCartesianDumper]
   :module: libudevicex.Plugins

The arguments are the same as for createDumpAverage() with a few additions

:param relative_to_ov: take an object governing the frame of reference from this :any:`ObjectVector`
:param relative_to_id: take an object governing the frame of reference with the specific ID


.. py:function:: createDumpMesh(compute_task: bool, name: str, ov: libudevicex.ParticleVectors.ObjectVector, dump_every: int, path: str) -> Tuple[libudevicex.Plugins.MeshPlugin, libudevicex.Plugins.MeshDumper]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param ov: :any:`ObjectVector` that we'll work with
:param dump_every: write files every this many time-steps
:param path: the files will look like this: <path>/<ov_name>_NNNNN.ply


.. py:function:: createDumpObjectStats(compute_task: bool, name: str, ov: libudevicex.ParticleVectors.ObjectVector, dump_every: int, path: str) -> Tuple[libudevicex.Plugins.ObjPositions, libudevicex.Plugins.ObjPositionsDumper]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param ov: :any:`ObjectVector` that we'll work with
:param dump_every: write files every this many time-steps
:param path: the files will look like this: <path>/<ov_name>_NNNNN.txt


.. py:function:: createDumpXYZ(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, dump_every: int, path: str) -> Tuple[libudevicex.Plugins.XYZPlugin, libudevicex.Plugins.XYZDumper]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :any:`ParticleVector` that we'll work with
:param dump_every: write files every this many time-steps
:param path: the files will look like this: <path>/<pv_name>_NNNNN.xyz


.. py:function:: createImposeProfile(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, low: Tuple[float, float, float], high: Tuple[float, float, float], velocity: Tuple[float, float, float], kbt: float) -> Tuple[libudevicex.Plugins.ImposeProfile, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :any:`ParticleVector` that we'll work with
:param low: the lower corner of the domain
:param high: the higher corner of the domain
:param velocity: target velocity
:param kbt: temperature in the domain (appropriate Maxwell distribution will be used)


.. py:function:: createImposeVelocity(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, every: int, low: Tuple[float, float, float], high: Tuple[float, float, float], velocity: Tuple[float, float, float]) -> Tuple[libudevicex.Plugins.ImposeVelocity, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :any:`ParticleVector` that we'll work with
:param every: change the velocities once in **every** timestep
:param low: the lower corner of the domain
:param high: the higher corner of the domain
:param velocity: target velocity


.. py:function:: createPinObject(compute_task: bool, name: str, ov: libudevicex.ParticleVectors.ObjectVector, dump_every: int, path: str, pin_translation: Tuple[int, int, int], pin_rotation: Tuple[int, int, int]) -> Tuple[libudevicex.Plugins.PinObject, libudevicex.Plugins.ReportPinObject]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :any:`ObjectVector` that we'll work with
:param dump_every: write files every this many time-steps
:param path: the files will look like this: <path>/<ov_name>_NNNNN.txt
:param pin_translation: 3 integers; 0 means that motion along the corresponding axis is unrestricted, 1 means fixed position wrt to the axis
:param pin_rotation: 3 integers; 0 means that rotation along the corresponding axis is unrestricted, 1 means fixed rotation wrt to the axis


.. py:function:: createStats(compute_task: bool, name: str, filename: str, every: int) -> Tuple[libudevicex.Plugins.SimulationStats, libudevicex.Plugins.PostprocessStats]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param filename: the stats will also be recorded to that file in a computer-friendly way
:param every: report to standard output every that many time-steps


.. py:function:: createTemperaturize(arg0: bool, arg1: str, arg2: libudevicex.ParticleVectors.ParticleVector, arg3: float, arg4: bool) -> Tuple[libudevicex.Plugins.Temperaturize, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

TODO


.. py:function:: createVelocityControl(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, low: Tuple[float, float, float], high: Tuple[float, float, float], every: int, targetVel: Tuple[float, float, float], Kp: float, Ki: float, Kd: float) -> Tuple[libudevicex.Plugins.VelocityControl, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :class:`ParticleVector` that we'll work with
:param low, high: boundaries of the domain of interest
:param every: write files every this many time-steps
:param targetVel: the target mean velocity of the particles in the domain of interest
:param Kp, Ki, Kd: PID controller coefficients


.. py:function:: createWallRepulsion(compute_task: bool, name: str, pv: libudevicex.ParticleVectors.ParticleVector, wall: libudevicex.Walls.Wall, C: float, h: float, max_force: float) -> Tuple[libudevicex.Plugins.WallRepulsion, libudevicex.Plugins.PostprocessPlugin]
   :module: libudevicex.Plugins

:param name: name of the plugin
:param pv: :any:`ParticleVector` that we'll work with
:param wall: :any:`Wall` that defines the repulsion
:param C: :math:`C`
:param h: :math:`h`
:param max_force: :math:`F_{max}`

