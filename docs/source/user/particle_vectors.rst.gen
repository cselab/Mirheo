.. _user-pv:

Particle Vectors
################

:any:`ParticleVector` (or PV) is a collection of particles in the simulation with identical properties. PV is the minimal unit of particles that can be addressed by most of the processing utilities, i.e. it is possible to specify interactions between different (or same) PVs, apply integrators, plugins, etc. to the PVs.

Each particle in the PV keeps its coordinate, velocity and force. Additional quantities may also be stored in a form of extra channels. These quantities are usually added and used by specific handlers, and can in principle be written in XDMF format (Average3D), see more detail in the Developer documentation.

A common special case of the ParticleVector is an :any:`ObjectVector` (or OV), which is a Particle Vector with the particles separated into groups (objects) of the same size. Objects are assumed to be spatially localized, so they always fully reside of a single MPI process. OV can be used in most of the places where a regular PV is used, and more

.. comment libudevicex.ParticleVectors
   :members:
   :show-inheritance:
   :undoc-members:
   :special-members: __init__
      
 

.. py:module:: libudevicex.ParticleVectors


.. py:class:: MembraneMesh
   :module: libudevicex.ParticleVectors

   Bases: :class:`libudevicex.ParticleVectors.Mesh`

Internally used class for desctibing a triangular mesh that can be used with the Membrane Interactions.
In contrast with the simple :any:`Mesh`, this class precomputes some required quantities on the mesh


.. py:method:: MembraneMesh.__init__(self: libudevicex.ParticleVectors.MembraneMesh, off_filename: str) -> None
   :module: libudevicex.ParticleVectors

Create a mesh by reading the OFF file
:param off_filename: path of the OFF file


.. py:class:: MembraneVector
   :module: libudevicex.ParticleVectors

   Bases: :class:`libudevicex.ParticleVectors.ObjectVector`

Membrane is an Object Vector representing cell membranes.
It must have a triangular mesh associated with it such that each particle is mapped directly onto single mesh vertex.


.. py:method:: MembraneVector.__init__(self: libudevicex.ParticleVectors.MembraneVector, name: str, mass: float, object_size: int, mesh: libudevicex.ParticleVectors.MembraneMesh) -> None
   :module: libudevicex.ParticleVectors

:param name: name of the created PV
:param mass: mass of a single particle
:param object_size: number of particles per membrane, must be the same as the number of vertices of the mesh
:param mesh: :any:`MembraneMesh` object


.. py:class:: Mesh
   :module: libudevicex.ParticleVectors

   Bases: :class:`pybind11_builtins.pybind11_object`

Internally used class for desctibing a simple triangular mesh


.. py:method:: Mesh.__init__(self: libudevicex.ParticleVectors.Mesh, off_filename: str) -> None
   :module: libudevicex.ParticleVectors

Create a mesh by reading the OFF file
:param off_filename: path of the OFF file


.. py:class:: ObjectVector
   :module: libudevicex.ParticleVectors

   Bases: :class:`libudevicex.ParticleVectors.ParticleVector`

Basic Object Vector


.. py:attribute:: ObjectVector.__init__
   :module: libudevicex.ParticleVectors

Initialize self.  See help(type(self)) for accurate signature.

.. py:class:: ParticleVector
   :module: libudevicex.ParticleVectors

   Bases: :class:`pybind11_builtins.pybind11_object`

Basic particle vector, consists of identical disconnected particles.


.. py:method:: ParticleVector.__init__(self: libudevicex.ParticleVectors.ParticleVector, name: str, mass: float) -> None
   :module: libudevicex.ParticleVectors

:param name: name of the created PV
:param mass: mass of a single particle


.. py:method:: ParticleVector.getCoordinates(self: libudevicex.ParticleVectors.ParticleVector) -> List[List[float[3]]]
   :module: libudevicex.ParticleVectors

:returns: 3 components of coordinate for every of the N particles
:rtype: A list of :math:`N \times 3` floats


.. py:method:: ParticleVector.getForces(self: libudevicex.ParticleVectors.ParticleVector) -> List[List[float[3]]]
   :module: libudevicex.ParticleVectors

:returns: 3 components of force for every of the N particles
:rtype: A list of :math:`N \times 3` floats


.. py:method:: ParticleVector.getVelocities(self: libudevicex.ParticleVectors.ParticleVector) -> List[List[float[3]]]
   :module: libudevicex.ParticleVectors

:returns: 3 components of velocity for every of the N particles
:rtype: A list of :math:`N \times 3` floats


.. py:method:: ParticleVector.setCoordinates(self: libudevicex.ParticleVectors.ParticleVector, coordinates: List[List[float[3]]]) -> None
   :module: libudevicex.ParticleVectors

:param coordinates: A list of :math:`N \times 3` floats: 3 components of coordinate for every of the N particles


.. py:method:: ParticleVector.setForces(self: libudevicex.ParticleVectors.ParticleVector, forces: List[List[float[3]]]) -> None
   :module: libudevicex.ParticleVectors

:param forces: A list of :math:`N \times 3` floats: 3 components of force for every of the N particles


.. py:method:: ParticleVector.setVelocities(self: libudevicex.ParticleVectors.ParticleVector, velocities: List[List[float[3]]]) -> None
   :module: libudevicex.ParticleVectors

:param velocities: A list of :math:`N \times 3` floats: 3 components of velocity for every of the N particles


.. py:class:: RigidEllipsoidVector
   :module: libudevicex.ParticleVectors

   Bases: :class:`libudevicex.ParticleVectors.ObjectVector`

Rigid Ellipsoid is the same as the Rigid Object except that it can only represent ellipsoidal shapes.
The advantage is that it doesn't need mesh and moment of inertia define, as those can be computed analytically.


.. py:method:: RigidEllipsoidVector.__init__(self: libudevicex.ParticleVectors.RigidEllipsoidVector, name: str, mass: float, object_size: int, semi_axes: Tuple[float, float, float]) -> None
   :module: libudevicex.ParticleVectors

:param name: name of the created PV
:param mass: mass of a single particle
:param object_size: number of particles per membrane, must be the same as the number of vertices of the mesh
:param semi_axes: ellipsoid principal semi-axes


.. py:class:: RigidObjectVector
   :module: libudevicex.ParticleVectors

   Bases: :class:`libudevicex.ParticleVectors.ObjectVector`

Rigid Object is an Object Vector representing objects that move as rigid bodies, with no relative displacement against each other in an object.
It must have a triangular mesh associated with it that defines the shape of the object.


.. py:method:: RigidObjectVector.__init__(self: libudevicex.ParticleVectors.RigidObjectVector, name: str, mass: float, inertia: Tuple[float, float, float], object_size: int, mesh: libudevicex.ParticleVectors.Mesh) -> None
   :module: libudevicex.ParticleVectors

:param name: name of the created PV
:param mass: mass of a single particle
:param inertia: moment of inertia of the body in its principal axes. The principal axes of the mesh are assumed to be aligned with the default global *OXYZ* axes
:param object_size: number of particles per membrane, must be the same as the number of vertices of the mesh
:param mesh: :any:`MembraneMesh` object

