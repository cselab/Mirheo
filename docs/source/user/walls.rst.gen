.. _user-walls:

Walls
#####

Walls are used to represent time-independent stationary boundary conditions for the flows. They are described in the form of a signed distance function (LINK), such that a zero-level isosurface defines the wall surface. No slip and no through boundary conditions are enforced on that surface by bouncing the particles off the wall surface.

In order to prevent undesired density oscillations near the walls, so called frozen particles are used. These non-moving particles reside inside the walls and interact with the regular liquid particles. If the density and distribution of the frozen particles is the same as of the corresponding liquid particles, the density oscillations in the liquid in proximity of the wall is minimal (LINK).

In the beginning of the simulation all the particles define in the simulation (even not attached to the wall by class::udevicex) will be checked against all the walls. Those inside the wall as well as objects partly inside the wall will be deleted. The only exception is the PVs that are named exactly as the wall, these PVs will be unaffected by their “parent” wall.

.. comment libudevicex.Walls
   :members:
   :show-inheritance:
   :undoc-members:
   :special-members: __init__









    

.. py:module:: libudevicex.Walls


.. py:class:: Box
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Rectangular cuboid wall with edges aligned with the coordinate axes.



.. py:method:: Box.__init__(self: libudevicex.Walls.Box, name: str, low: Tuple[float, float, float], high: Tuple[float, float, float], inside: bool = False) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param low: lower corner of the box
:param high: higher corner of the box
:param inside: whether the domain is inside the box or outside of it


.. py:class:: Cylinder
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Cylindrical infinitely stretching wall, the main axis is aligned along OX or OY or OZ


.. py:method:: Cylinder.__init__(self: libudevicex.Walls.Cylinder, name: str, center: Tuple[float, float], radius: float, axis: str, inside: bool = False) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param center: point that belongs to the cylinder axis projected along that axis
:param radius: cylinder radius
:param axis: direction of cylinder axis, valid values are "x", "y" or "z"
:param inside: whether the domain is inside the cylinder or outside of it


.. py:class:: MovingPlane
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Planar wall that is moving along itself with constant velocity.
Can be used to produce Couette velocity profile in combination with
The boundary conditions on such wall are no-through and constant velocity (specified).


.. py:method:: MovingPlane.__init__(self: libudevicex.Walls.MovingPlane, name: str, normal: Tuple[float, float, float], pointThrough: Tuple[float, float, float], velocity: Tuple[float, float, float]) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param normal: wall normal, pointing *inside* the wall
:param pointThrough: point that belongs to the plane
:param velocity: wall velocity, should be orthogonal to the normal


.. py:class:: OscillatingPlane
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Planar wall that is moving along itself with periodically changing velocity:

.. math::
    \mathbf{u}(t) = cos(2*\pi * t / T);


.. py:method:: OscillatingPlane.__init__(self: libudevicex.Walls.OscillatingPlane, name: str, normal: Tuple[float, float, float], pointThrough: Tuple[float, float, float], velocity: Tuple[float, float, float], period: float) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param normal: wall normal, pointing *inside* the wall
:param pointThrough: point that belongs to the plane
:param velocity: velocity amplitude, should be orthogonal to the normal
:param period: oscillation period in number of timesteps


.. py:class:: Plane
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Planar infinitely stretching wall. Inside is determined by the normal direction .



.. py:method:: Plane.__init__(self: libudevicex.Walls.Plane, name: str, normal: Tuple[float, float, float], pointThrough: Tuple[float, float, float]) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param normal: wall normal, pointing *inside* the wall
:param pointThrough: point that belongs to the plane


.. py:class:: RotatingCylinder
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Cylindrical wall rotating with constant angular velocity along its axis.


.. py:method:: RotatingCylinder.__init__(self: libudevicex.Walls.RotatingCylinder, name: str, center: Tuple[float, float], radius: float, axis: str, omega: float, inside: bool = False) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param center: point that belongs to the cylinder axis projected along that axis
:param radius: cylinder radius
:param axis: direction of cylinder axis, valid values are "x", "y" or "z"
:param omega: angular velocity of rotation along the cylinder axis
:param inside: whether the domain is inside the cylinder or outside of it


.. py:class:: SDF
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

This wall is based on an arbitrary Signed Distance Function defined in the simulation domain on a regular cartesian grid.
The wall reads the SDF data from a .sdf file, that has a special structure.

First two lines define the header: three real number separated by spaces govern the size of the domain where the SDF is defined,
and next three integer numbers (:math:`Nx\,\,Ny\,\,Nz`) define the resolution.
Next the :math:`Nx \times Ny \times Nz` single precision floating point values are written (in binary representation).

Negative SDF values correspond to the domain, and positive -- to the inside of the wall.
Therefore the boundary is defined by the zero-level isosurface.


.. py:method:: SDF.__init__(self: libudevicex.Walls.SDF, name: str, sdfFilename: str, h: Tuple[float, float, float] = (0.25, 0.25, 0.25)) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param sdfFilename: lower corner of the box
:param h: resolution of the resampled SDF. In order to have a more accurate SDF representation, the initial function is resampled on a finer grid. The lower this value is, the better the wall will be, however, the  more memory it will consume and the slower the execution will be


.. py:class:: Sphere
   :module: libudevicex.Walls

   Bases: :class:`libudevicex.Walls.Wall`

Spherical wall.



.. py:method:: Sphere.__init__(self: libudevicex.Walls.Sphere, name: str, center: Tuple[float, float, float], raduis: float, inside: bool = False) -> None
   :module: libudevicex.Walls

:param name: name of the wall
:param center: sphere center
:param radius: sphere radius
:param inside: whether the domain is inside the sphere or outside of it


.. py:class:: Wall(*args, **kwargs)
   :module: libudevicex.Walls

   Bases: :class:`pybind11_builtins.pybind11_object`

Base wall class.


.. py:method:: Wall.__init__(*args, **kwargs)
   :module: libudevicex.Walls

Initialize self.  See help(type(self)) for accurate signature.

